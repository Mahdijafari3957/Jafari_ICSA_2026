package edu.kit.pentest.generation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.palladiosimulator.pcm.allocation.Allocation;
import org.palladiosimulator.pcm.allocation.AllocationPackage;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.repository.Interface;
import org.palladiosimulator.pcm.repository.OperationInterface;
import org.palladiosimulator.pcm.repository.OperationProvidedRole;
import org.palladiosimulator.pcm.repository.OperationRequiredRole;
import org.palladiosimulator.pcm.repository.Repository;
import org.palladiosimulator.pcm.repository.RepositoryComponent;
import org.palladiosimulator.pcm.repository.RepositoryPackage;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;
import org.palladiosimulator.pcm.resourceenvironment.ResourceEnvironment;
import org.palladiosimulator.pcm.resourceenvironment.ResourceenvironmentPackage;
import org.palladiosimulator.pcm.system.System;
import org.palladiosimulator.pcm.system.SystemPackage;

import edu.kit.pentest.model.AttackStep;
import edu.kit.pentest.model.AttackVector;
import edu.kit.pentest.model.Component;
import edu.kit.pentest.model.Connector;
import edu.kit.pentest.model.PenTestCase;
import edu.kit.pentest.model.PenTestCaseRepository;
import edu.kit.pentest.model.PentestFactory;
import edu.kit.pentest.model.PentestPackage;
import edu.kit.pentest.model.SecurityProperty;
import edu.kit.pentest.model.Threat;
import edu.kit.pentest.sidechannel.LinkSideChannelAnnotation;
import edu.kit.pentest.sidechannel.ResourceSideChannelAnnotation;
import edu.kit.pentest.sidechannel.SideChannel;
import edu.kit.pentest.sidechannel.SideChannelRepository;
import edu.kit.pentest.sidechannel.SidechannelFactory;
import edu.kit.pentest.sidechannel.SidechannelPackage;
import edu.kit.pentest.zone.Zone;
import edu.kit.pentest.zone.ZonePackage;
import edu.kit.pentest.zone.ZoneRepository;

public class PenTestCaseGeneration {
	
	public PenTestCaseRepository generatePTCs(String basePath, String repositoryPath, String systemPath, String resourceEnvironmentPath, String allocationPath, String sideChannelPath, String zonePath, String exportPath) {
		var ptcrepo = generatePTCs(basePath, repositoryPath, systemPath, resourceEnvironmentPath, allocationPath, sideChannelPath, zonePath);
		var res = new XMIResourceFactoryImpl().createResource(URI.createFileURI(exportPath));
		res.getContents().add(ptcrepo);
		try {
			res.save(Map.of());
		} catch (IOException e) {
			e.printStackTrace();
		}
		return ptcrepo;
	}

	public PenTestCaseRepository generatePTCs(String basePath, String repositoryPath, String systemPath, String resourceEnvironmentPath, String allocationPath, String sideChannelPath, String zonePath) {

		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("*", new XMIResourceFactoryImpl());

		// Register your packages
		RepositoryPackage.eINSTANCE.eClass();
		SystemPackage.eINSTANCE.eClass();
		ResourceenvironmentPackage.eINSTANCE.eClass();
		AllocationPackage.eINSTANCE.eClass();
		SidechannelPackage.eINSTANCE.eClass();
		ZonePackage.eINSTANCE.eClass();
		PentestPackage.eINSTANCE.eClass();

		ResourceSet resourceSet = new ResourceSetImpl();

		// Workspace-relative URIs
		
		String baseWorkspace = basePath;

		Repository repository = loadModel(resourceSet, baseWorkspace + repositoryPath,
				Repository.class);
		System system = loadModel(resourceSet, baseWorkspace + systemPath, System.class);
		ResourceEnvironment resourceEnvironment = loadModel(resourceSet,
				baseWorkspace + resourceEnvironmentPath, ResourceEnvironment.class);
		Allocation allocation = loadModel(resourceSet, baseWorkspace + allocationPath,
				Allocation.class);
		SideChannelRepository sideChannels = loadModel(resourceSet, baseWorkspace + sideChannelPath,
				SideChannelRepository.class);
		ZoneRepository zones = loadModel(resourceSet, baseWorkspace + zonePath,
				ZoneRepository.class);

		return generateTestCases(repository, system, resourceEnvironment, allocation, sideChannels, zones);

	}

	private <T> T loadModel(ResourceSet resourceSet, String uriString, Class<T> clazz) {
		URI uri = URI.createFileURI(uriString);
		Resource resource = resourceSet.getResource(uri, true);
		try {
			resource.load(Collections.EMPTY_MAP);
		} catch (IOException e) {
			throw new RuntimeException("Failed to load model: " + uriString, e);
		}
		return clazz.cast(resource.getContents().get(0));
	}

	private PenTestCaseRepository generateTestCases(Repository repository, System system, ResourceEnvironment resourceEnvironment,
			Allocation allocation, SideChannelRepository sideChannels, ZoneRepository zones) {
		// search for each resource container which has multiple zones on it and each
		// linking resource which connects allocation contexts which have different
		// zones on them
		Map<ResourceContainer, RepositoryComponent> deployment = new HashMap<>();
		Map<ResourceContainer, List<OperationInterface>> interfaces = new HashMap<>();
		Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping = new HashMap<>();
		PenTestCaseRepository ptcrepo = PentestFactory.eINSTANCE.createPenTestCaseRepository();

		fillDataStructures(repository, allocation, zones, deployment, interfaces, zonemapping);

		generatePenTestCasesForResourceContainers(zonemapping, ptcrepo, sideChannels);

		resourceEnvironment.getLinkingResources__ResourceEnvironment().forEach(it -> {
			List<ComponentFlow> allFlows = generateFlowsForLinkingResource(zonemapping, it);
			generatePTCForLinkingResource(sideChannels, ptcrepo, allFlows);

		});

		return ptcrepo;
	}

	private void fillDataStructures(Repository repository, Allocation allocation, ZoneRepository zones,
			Map<ResourceContainer, RepositoryComponent> deployment,
			Map<ResourceContainer, List<OperationInterface>> interfaces,
			Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping) {
		allocation.getAllocationContexts_Allocation().forEach(it -> {
			// for an allocation context, get the assembly contexts deployed on it
			RepositoryComponent repositoryComponent = it.getAssemblyContext_AllocationContext()
					.getEncapsulatedComponent__AssemblyContext();
			List<OperationInterface> continterfaces = new ArrayList<>();
			continterfaces.addAll(repositoryComponent.getProvidedRoles_InterfaceProvidingEntity().stream()
					.map(role -> (OperationProvidedRole) role)
					.map(role -> role.getProvidedInterface__OperationProvidedRole()).toList());
			continterfaces.addAll(repositoryComponent.getRequiredRoles_InterfaceRequiringEntity().stream()
					.map(role -> (OperationRequiredRole) role)
					.map(role -> role.getRequiredInterface__OperationRequiredRole()).toList());
			repository.getComponents__Repository().stream().filter(comp -> comp.equals(repositoryComponent)).findFirst()
					.get();
			List<Zone> zoneList = zones.getZoneAnnotations().stream()
					.filter(anno -> continterfaces.contains(anno.getInterface()))
					.map(annotation -> annotation.getZone()).toList();
			interfaces.put(it.getResourceContainer_AllocationContext(), continterfaces);
			deployment.put(it.getResourceContainer_AllocationContext(), repositoryComponent);
			if (zonemapping.containsKey(it.getResourceContainer_AllocationContext())) {
				zonemapping.get(it.getResourceContainer_AllocationContext()).put(it.getAssemblyContext_AllocationContext(), zoneList);
			} else {
				Map<AssemblyContext, List<Zone>> map = new HashMap<>();
				map.put(it.getAssemblyContext_AllocationContext(), zoneList);
				zonemapping.put(it.getResourceContainer_AllocationContext(),map);
			}
			

		});
	}

	private List<ComponentFlow> generateFlowsForLinkingResource(
			Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping, LinkingResource it) {
		var rcs = it.getConnectedResourceContainers_LinkingResource();
		List<ComponentFlow> allFlows = new ArrayList<>();
		for (var rc : rcs) {
			// for each component that is connected by the linking resource
			for (var ac : zonemapping.get(rc).keySet()) {
				// for each assembly component it gets the list of zones
				List<Zone> rczones = zonemapping.get(rc).get(ac);
				// and for all other resource containers
				for (var otherrc : rcs) {
					if (otherrc.equals(rc))
						continue;
					// checks their zonemappings
					for (var otherac : zonemapping.get(otherrc).keySet()) {
						allFlows.addAll(flowsBetween(rczones, zonemapping.get(otherrc).get(otherac), rc, otherrc,
								it, ac, otherac));
					}
				}
			}
		}
		return allFlows;
	}

	private void generatePTCForLinkingResource(SideChannelRepository sideChannels, PenTestCaseRepository ptcrepo,
			List<ComponentFlow> allFlows) {
		List<SideChannel> availableChannels = new ArrayList<>();
		availableChannels.addAll(sideChannels.getSideChannelAnnotations().stream()
				.filter(sca -> sca instanceof LinkSideChannelAnnotation).map(sca -> (LinkSideChannelAnnotation) sca)
				.map(sca -> sca.getSideChannel()).toList());
		for (var flow : allFlows) {
			var investigate = SidechannelFactory.eINSTANCE.createSideChannel();
			investigate.setName("Investigate");
			List<SideChannel> channels = new ArrayList<>();
			channels.add(investigate);
			channels.addAll(availableChannels);
			for (var sc : channels) {
				int index = 0;

				Component ep = generateComponent(flow.start, flow.acstart);
				Component as = generateComponent(flow.end, flow.acend);
				AttackVector av = flow.connector!=null ? generateAV(sc, ep, index, as, generateConnector(flow.connector, null)) : generateAV(sc, ep, index, as);
				String title = availableChannels.contains(sc)?String.format("Explicitly annotated side channel for Interface %s with zone (%d) -> Interface %s with zone (%d)%n",
						flow.from().getName(), flow.from().getConfidentialityLevel(), flow.to().getName(),
						flow.to().getConfidentialityLevel()):String.format("Interface %s with zone (%d) -> Interface %s with zone (%d)%n",
								flow.from().getName(), flow.from().getConfidentialityLevel(), flow.to().getName(),
								flow.to().getConfidentialityLevel());
				var ptc = generatePTC(title,
						getCorrespondingThreat(sc), av, getCorrespondingSecurityProperty(sc));
				
				if (availableChannels.contains(sc)) {
					ptcrepo.getPrioritizedPentestcases().add(ptc);
				} else {
					ptcrepo.getPentestcases().add(ptc);
				}
			}
		}
	}

	static List<ComponentFlow> flowsBetween(List<Zone> sourceZones, List<Zone> targetZones, ResourceContainer start,
			ResourceContainer end, LinkingResource connector, AssemblyContext acstart, AssemblyContext acend) {
		return IntStream.range(0, sourceZones.size()).boxed()
				.flatMap(i -> IntStream.range(0, targetZones.size()).mapToObj(j -> new ComponentFlow(sourceZones.get(i), // from
						targetZones.get(j), // to
						start, // start container
						end, // end container
						connector, // linking resource
						acstart, acend)))
				.filter(cf -> cf.from().getConfidentialityLevel() < cf.to().getConfidentialityLevel()).toList();
	}

	record Flow(Zone from, Zone to) {
	}

	record ComponentFlow(Zone from, Zone to, ResourceContainer start, ResourceContainer end, LinkingResource connector,
			AssemblyContext acstart, AssemblyContext acend) {
	}

	private void generatePenTestCasesForResourceContainers(Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping,
			PenTestCaseRepository ptcrepo, SideChannelRepository screpo) {
		List<ComponentFlow> allFlows = new ArrayList<>();
		for (ResourceContainer rc : zonemapping.keySet()) {
			java.lang.System.out.println(rc.getEntityName());
        	for(var ac : zonemapping.get(rc).keySet()) {
        		java.lang.System.out.println(ac.getEntityName());
	        	List<Zone> rczones = zonemapping.get(rc).get(ac);
	        	if (rczones.size() > 1) {
	        		// we have multiple zones in one assembly context on one resource container, so we generate PTC for each combination of flowing from lower to higher
					List<Flow> flows =
					    IntStream.range(0, rczones.size())
					        .boxed()
					        .flatMap(i ->
					            IntStream.range(0, rczones.size())
					                     .filter(j -> j != i)
					                     .mapToObj(j -> new Flow(rczones.get(i), rczones.get(j)))
					        )
					        .filter(f -> f.from().getConfidentialityLevel() < f.to().getConfidentialityLevel())
					        .toList();
	
					for (var flow : flows) {
						var investigate = SidechannelFactory.eINSTANCE.createSideChannel();
						investigate.setName("Investigate");
						List<SideChannel> channels = new ArrayList<>();
						channels.add(investigate);
						channels.addAll(screpo.getSideChannels());
						for (var sc : channels) {
							var annotatedChannels = screpo.getSideChannelAnnotations().stream().filter(it -> it instanceof ResourceSideChannelAnnotation)
									.map(it -> (ResourceSideChannelAnnotation)it).filter(it -> it.getArchitecturalElement().equals(rc)).map(it -> it.getSideChannel()).toList();
							int index = 0;
							// entrypoint and asset are the same rc, because we are on the same resource container
							Component ep = generateComponent(rc, ac);
							Component as = generateComponent(rc, ac);
							
							AttackVector av = generateAV(sc, ep, index, as);
							String title = annotatedChannels.contains(sc)?String.format("Explicitly annotated side channel for Interface %s with zone (%d) -> Interface %s with zone (%d)%n",
									flow.from().getName(), flow.from().getConfidentialityLevel(), flow.to().getName(),
									flow.to().getConfidentialityLevel()):String.format("Interface %s with zone (%d) -> Interface %s with zone (%d)%n",
											flow.from().getName(), flow.from().getConfidentialityLevel(), flow.to().getName(),
											flow.to().getConfidentialityLevel());
							var ptc = generatePTC(title,
										getCorrespondingThreat(sc), av, getCorrespondingSecurityProperty(sc));
							
							
							if (annotatedChannels.contains(sc)) {
								ptcrepo.getPrioritizedPentestcases().add(ptc);
							} else {
								ptcrepo.getPentestcases().add(ptc);
							}
						}
					}
	        	}
	        	for (var otherac : zonemapping.get(rc).keySet()) {
	        		if(ac.equals(otherac))continue;
	        		allFlows.addAll(flowsBetween(rczones, zonemapping.get(rc).get(otherac), rc, rc,
							null, ac, otherac));
				}
        	
        	}
        }
		generatePTCForLinkingResource(screpo, ptcrepo, allFlows);
	}

	private Connector generateConnector(LinkingResource lr, Interface interf) {
		Connector as = PentestFactory.eINSTANCE.createConnector();
		as.setLinkingResource(lr);
		as.setImplInterface(interf);
		as.setName(as.getLinkingResource().getEntityName() + " connecting with (optional) interface "
				+ (as.getImplInterface() != null ? as.getImplInterface().getEntityName() : ""));
		return as;
	}

	private Component generateComponent(ResourceContainer rc, AssemblyContext ac) {
		Component as = PentestFactory.eINSTANCE.createComponent();
		as.setAssemblyContext(ac);
		as.setResourceContainer(rc);
		as.setName(
				as.getAssemblyContext().getEntityName() + " deployed on " + as.getResourceContainer().getEntityName());
		return as;
	}

	private AttackVector generateAV(SideChannel sc, Component ep, int index, Component as) {
		return generateAV(sc, ep, index, as, null);
	}

	private AttackVector generateAV(SideChannel sc, Component ep, int index, Component as, Connector connector) {
		var av = PentestFactory.eINSTANCE.createAttackVector();
		av.setName("Exploited side channel: " + sc.getName());
		av.setEntryPoint(generateAS(ep, ""+index++));
		av.setAsset(generateAS(as, ""+index++));
		av.setConnector(connector);
		return av;
	}

	private AttackStep generateAS(Component executedOn, String id) {
		AttackStep as = PentestFactory.eINSTANCE.createAttackStep();
		as.setExecutedOn(executedOn);
		as.setId(id + " executed on " + executedOn.getName());
		return as;
	}

	private PenTestCase generatePTC(String id, Threat assesedThreat, AttackVector attackVector,
			SecurityProperty violatedProperty) {
		var ptc = PentestFactory.eINSTANCE.createPenTestCase();
		ptc.setId(id);
		ptc.setAssessedThreat(assesedThreat);
		ptc.setUsedAttackVector(attackVector);
		ptc.getViolatedSecurityProperties().add(violatedProperty);
		return ptc;
	}

	private Threat getCorrespondingThreat(SideChannel sideChannel) {
		switch (sideChannel.getName()) {
		case "Timing": {
			Threat threat = PentestFactory.eINSTANCE.createThreat();
			threat.setName("Possible Information leakage through timing side channel.");
			return threat;
		}
		case "Visual": {
			Threat threat = PentestFactory.eINSTANCE.createThreat();
			threat.setName(
					"Possible Information leakage through visual side channel, i.e., a user may see (parts of) the contents of the interface of another user.");
			return threat;
		}
		case "Investigate": {
			Threat threat = PentestFactory.eINSTANCE.createThreat();
			threat.setName("This side channel is unknow, please investigate possible side channels.");
			return threat;
		}

		default:
			throw new IllegalArgumentException("Unexpected value: " + sideChannel.getName());
		}
	}

	private SecurityProperty getCorrespondingSecurityProperty(SideChannel sideChannel) {
		switch (sideChannel.getName()) {
		case "Timing": {
			return SecurityProperty.CONFIDENTIALITY;
		}
		case "Visual": {
			return SecurityProperty.CONFIDENTIALITY;
		}
		case "Investigate": {
			return SecurityProperty.CONFIDENTIALITY;
		}
		default:
			throw new IllegalArgumentException("Unexpected value: " + sideChannel.getName());
		}
	}
}
