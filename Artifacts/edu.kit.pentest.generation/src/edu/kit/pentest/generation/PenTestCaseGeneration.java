package edu.kit.pentest.generation;

import org.palladiosimulator.pcm.PcmPackage;
import org.palladiosimulator.pcm.allocation.Allocation;
import org.palladiosimulator.pcm.allocation.AllocationPackage;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.repository.OperationInterface;
import org.palladiosimulator.pcm.repository.OperationProvidedRole;
import org.palladiosimulator.pcm.repository.OperationRequiredRole;
import org.palladiosimulator.pcm.repository.Repository;
import org.palladiosimulator.pcm.repository.RepositoryComponent;
import org.palladiosimulator.pcm.repository.RepositoryPackage;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;
import org.palladiosimulator.pcm.resourceenvironment.ResourceEnvironment;
import org.palladiosimulator.pcm.resourceenvironment.ResourceenvironmentPackage;
import org.palladiosimulator.pcm.system.System;
import org.palladiosimulator.pcm.system.SystemPackage;

import edu.kit.pentest.sidechannel.ResourceSideChannelAnnotation;
import edu.kit.pentest.sidechannel.SideChannel;
import edu.kit.pentest.sidechannel.SideChannelRepository;
import edu.kit.pentest.sidechannel.SidechannelPackage;
import edu.kit.pentest.zone.Zone;
import edu.kit.pentest.zone.ZonePackage;
import edu.kit.pentest.zone.ZoneRepository;
import edu.kit.pentest.model.AttackStep;
import edu.kit.pentest.model.AttackVector;
import edu.kit.pentest.model.Component;
import edu.kit.pentest.model.PenTestCase;
import edu.kit.pentest.model.PenTestCaseRepository;
import edu.kit.pentest.model.PentestFactory;
import edu.kit.pentest.model.PentestPackage;
import edu.kit.pentest.model.SecurityProperty;
import edu.kit.pentest.model.Threat;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceFactoryImpl;
import org.eclipse.emf.ecore.resource.impl.ResourceImpl;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;


import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;



public class PenTestCaseGeneration {
	
	public static void main(String[] args) {

Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("allocation", new XMIResourceFactoryImpl());
        Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("repository", new XMIResourceFactoryImpl());
        Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("resourceenvironment", new XMIResourceFactoryImpl());
        Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("system", new XMIResourceFactoryImpl());
        Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("sidechannel", new XMIResourceFactoryImpl());
        Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap()
            .put("zone", new XMIResourceFactoryImpl());

        // Register your packages
        RepositoryPackage.eINSTANCE.eClass();
        SystemPackage.eINSTANCE.eClass();
        ResourceenvironmentPackage.eINSTANCE.eClass();
        AllocationPackage.eINSTANCE.eClass();
        SidechannelPackage.eINSTANCE.eClass();
        ZonePackage.eINSTANCE.eClass();
        PentestPackage.eINSTANCE.eClass();

        ResourceSet resourceSet = new ResourceSetImpl();

        // Workspace-relative URIs
        String baseWorkspace = "file:/D:/temp/ICSA26/Jafari_ICSA_2026/Artifacts/edu.kit.pentest.runningexample/model/";

        Repository repository = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.repository", Repository.class);
        System system = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.system", System.class);
        ResourceEnvironment resourceEnvironment = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.resourceenvironment", ResourceEnvironment.class);
        Allocation allocation = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.allocation", Allocation.class);
        SideChannelRepository sideChannels = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.sidechannel", SideChannelRepository.class);
        ZoneRepository zones = loadModel(resourceSet, baseWorkspace + "AppointmentManagement.zone", ZoneRepository.class);
        
        generateTestCases(repository, system, resourceEnvironment, allocation, sideChannels, zones);

	}
	

private static <T> T loadModel(ResourceSet resourceSet, String uriString, Class<T> clazz) {
        URI uri = URI.createURI(uriString);
        Resource resource = resourceSet.getResource(uri, true);
        try {
            resource.load(Collections.EMPTY_MAP);
        } catch (IOException e) {
            throw new RuntimeException("Failed to load model: " + uriString, e);
        }
        return clazz.cast(resource.getContents().get(0));
    }

	
	private static void generateTestCases(Repository repository, System system, ResourceEnvironment resourceEnvironment, Allocation allocation, SideChannelRepository sideChannels, ZoneRepository zones) {
		 // Print loaded objects
        java.lang.System.out.println("Repository: " + repository);
        java.lang.System.out.println("System: " + system);
        java.lang.System.out.println("ResourceEnvironment: " + resourceEnvironment);
        java.lang.System.out.println("Allocation: " + allocation);
        java.lang.System.out.println("SideChannels: " + sideChannels);
        java.lang.System.out.println("Zones: " + zones);
        
        // search for each resource container which has multiple zones on it and each linking resource which connects allocation contexts which have different zones on them
        Map<ResourceContainer, RepositoryComponent> deployment = new HashMap<>();
        Map<ResourceContainer, List<OperationInterface>> interfaces = new HashMap<>();
        Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping = new HashMap<>();
        PenTestCaseRepository ptcrepo = PentestFactory.eINSTANCE.createPenTestCaseRepository();
        
        allocation.getAllocationContexts_Allocation().forEach(it -> {
        	// for an allocation context, get the assembly contexts deployed on it
        	RepositoryComponent repositoryComponent =  it.getAssemblyContext_AllocationContext().getEncapsulatedComponent__AssemblyContext();
        	List<OperationInterface> continterfaces = new ArrayList();
        	continterfaces.addAll(repositoryComponent.getProvidedRoles_InterfaceProvidingEntity().stream().map(role -> (OperationProvidedRole)role).map(role -> role.getProvidedInterface__OperationProvidedRole()).toList());
        	continterfaces.addAll(repositoryComponent.getRequiredRoles_InterfaceRequiringEntity().stream().map(role -> (OperationRequiredRole)role).map(role -> role.getRequiredInterface__OperationRequiredRole()).toList());
        	repository.getComponents__Repository().stream().filter(comp -> comp.equals(repositoryComponent)).findFirst().get();
        	List<Zone> zoneList = zones.getZoneAnnotations().stream().filter(anno -> continterfaces.contains(anno.getInterface())).map(annotation -> annotation.getZone()).toList();
        	interfaces.put(it.getResourceContainer_AllocationContext(), continterfaces);
        	deployment.put(it.getResourceContainer_AllocationContext(), repositoryComponent);
        	zonemapping.put(it.getResourceContainer_AllocationContext(), Map.of(it.getAssemblyContext_AllocationContext(), zoneList));
        	
        });
        
        // TODO only look at the sidechannels that are annotated to a specific resourcecontainer
        List<SideChannel> availableChannels = new ArrayList();
        availableChannels.addAll(sideChannels.getSideChannelAnnotations().stream().filter(it -> it instanceof ResourceSideChannelAnnotation).map(it -> (ResourceSideChannelAnnotation)it).map(it -> it.getSideChannel()).toList());
        
        generatePenTestCases(zonemapping, ptcrepo, availableChannels);
        var res = new XMIResourceFactoryImpl().createResource(URI.createURI("export.xmi"));
        res.getContents().add(ptcrepo);
        try {
			res.save(Map.of());
		} catch (IOException e) {
			e.printStackTrace();
		}
        
//        resourceEnvironment.getLinkingResources__ResourceEnvironment().forEach(it -> {
//        	// for an allocation context, get the assembly contexts deployed on it
//        	var rc = it.getConnectedResourceContainers_LinkingResource();
//        	RepositoryComponent repositoryComponent =  it.getAssemblyContext_AllocationContext().getEncapsulatedComponent__AssemblyContext();
//        	List<OperationInterface> continterfaces = new ArrayList();
//        	continterfaces.addAll(repositoryComponent.getProvidedRoles_InterfaceProvidingEntity().stream().map(role -> (OperationProvidedRole)role).map(role -> role.getProvidedInterface__OperationProvidedRole()).toList());
//        	continterfaces.addAll(repositoryComponent.getRequiredRoles_InterfaceRequiringEntity().stream().map(role -> (OperationRequiredRole)role).map(role -> role.getRequiredInterface__OperationRequiredRole()).toList());
//        	repository.getComponents__Repository().stream().filter(comp -> comp.equals(repositoryComponent)).findFirst().get();
//        	List<Zone> zoneList = zones.getZoneAnnotations().stream().filter(anno -> continterfaces.contains(anno.getInterface())).map(annotation -> annotation.getZone()).toList();
//        	interfaces.put(it.getResourceContainer_AllocationContext(), continterfaces);
//        	deployment.put(it.getResourceContainer_AllocationContext(), repositoryComponent);
//        	zonemapping.put(it.getResourceContainer_AllocationContext(), Map.of(it.getAssemblyContext_AllocationContext(), zoneList));
//        	
//        });
        
        // TODO implement the same for the linking resources
	}


	private static void generatePenTestCases(Map<ResourceContainer, Map<AssemblyContext, List<Zone>>> zonemapping,
			PenTestCaseRepository ptcrepo, List<SideChannel> availableChannels) {
		for (var rc : zonemapping.keySet()) {
			java.lang.System.out.print(rc);
        	for(var ac : zonemapping.get(rc).keySet()) {
        		java.lang.System.out.println(ac + "" + zonemapping.get(rc).get(ac));
        	List<Zone> rczones = zonemapping.get(rc).get(ac);
        	if (rczones.size() > 1) {
        		java.lang.System.out.println("-----------------------------------------");
        		// we have multiple zones in one resouce container, so we generate PTC for each combination of flowing from lower to higher
        		java.lang.System.out.println(rc.getEntityName() + " " + rczones);
        		
				record Flow(Zone from, Zone to) {}

				List<Flow> flows =
				    IntStream.range(0, rczones.size())
				        .boxed()
				        .flatMap(i ->
				            IntStream.range(0, rczones.size())
				                     .filter(j -> j != i)
				                     .mapToObj(j -> new Flow(rczones.get(i), rczones.get(j)))
				        )
				        .filter(f -> f.from().getConfidentialityLevel() < f.to().getConfidentialityLevel())
				        .toList();


				// Print
				flows.forEach(f -> java.lang.System.out.printf("%s (%d) -> %s (%d)%n",
				    f.from().getName(), f.from().getConfidentialityLevel(),
				    f.to().getName(), f.to().getConfidentialityLevel()));
				for (var flow : flows) {
					for (var sc : availableChannels) {
						int index = 0;
						var av = PentestFactory.eINSTANCE.createAttackVector();
						av.setName("Exploited side channel: " + sc.getName());
						
						Component ep = PentestFactory.eINSTANCE.createComponent();
						// that is incorrect, there are multiple assembly contexts deployed on one resource container, so we have to find the one that is linked here
						ep.setAssemblyContext(ac);
						ep.setResourceContainer(rc);
						ep.setName(ep.getAssemblyContext().getEntityName() + " deployed on " +  ep.getResourceContainer().getEntityName());
						av.setEntryPoint(generateAS(ep, "step: " + index++));
						
						Component as = PentestFactory.eINSTANCE.createComponent();
						as.setAssemblyContext(ac);
						as.setResourceContainer(rc);
						as.setName(as.getAssemblyContext().getEntityName() + " deployed on " +  as.getResourceContainer().getEntityName());
						
						av.setAsset(generateAS(as, "step: " + index++));
						var ptc = generatePTC(String.format("Interface %s with zone (%d) -> Interface %s with zone (%d)%n",
							    flow.from().getName(), flow.from().getConfidentialityLevel(),
							    flow.to().getName(), flow.to().getConfidentialityLevel()),
									getCorrespondingThreat(sc), av, getCorrespondingSecurityProperty(sc));
						ptcrepo.getPentestcase().add(ptc);
					}
				}
        	}
				
        	}
        }
	}
	
	private static AttackStep generateAS(Component executedOn, String id) {
		AttackStep as = PentestFactory.eINSTANCE.createAttackStep();
		as.setExecutedOn(executedOn);
		as.setId(id);
		return as;
	}
	

	
	private static PenTestCase generatePTC(String id, Threat assesedThreat, AttackVector attackVector, SecurityProperty violatedProperty) {
		var ptc = PentestFactory.eINSTANCE.createPenTestCase();
		ptc.setId(id);
		ptc.setAssessedThreat(assesedThreat);
		ptc.setUsedAttackVector(attackVector);
		ptc.getViolatedSecurityProperties().add(violatedProperty);
		return ptc;
	}
	
	private static Threat getCorrespondingThreat(SideChannel sideChannel) {
		switch (sideChannel.getName()) {
		case "Timing": {
			Threat threat = PentestFactory.eINSTANCE.createThreat();
			threat.setName("Possible Information leakage through timing side channel.");
			return threat;
		}
		case "Visual": {
			Threat threat = PentestFactory.eINSTANCE.createThreat();
			threat.setName("Possible Information leakage through visual side channel, i.e., a user may see (parts of) the contents of the interface of another user.");
			return threat;
		}
		default:
			throw new IllegalArgumentException("Unexpected value: " + sideChannel.getName());
		}
	}
	
	private static SecurityProperty getCorrespondingSecurityProperty(SideChannel sideChannel) {
		switch (sideChannel.getName()) {
		case "Timing": {
			return SecurityProperty.CONFIDENTIALITY;
		}
		case "Visual": {
			return SecurityProperty.CONFIDENTIALITY;
		}
		default:
			throw new IllegalArgumentException("Unexpected value: " + sideChannel.getName());
		}
	}
}
